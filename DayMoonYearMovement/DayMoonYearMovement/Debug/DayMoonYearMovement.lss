
DayMoonYearMovement.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001aa  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000001fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000001fe  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000230  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000140  00000000  00000000  0000026c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000bb6  00000000  00000000  000003ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000633  00000000  00000000  00000f62  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000672  00000000  00000000  00001595  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000270  00000000  00000000  00001c08  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000079b  00000000  00000000  00001e78  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000177  00000000  00000000  00002613  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000130  00000000  00000000  0000278a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	a1 c0       	rjmp	.+322    	; 0x146 <__vector_1>
   4:	9f c0       	rjmp	.+318    	; 0x144 <__vector_2>
   6:	11 c0       	rjmp	.+34     	; 0x2a <__bad_interrupt>
   8:	10 c0       	rjmp	.+32     	; 0x2a <__bad_interrupt>
   a:	0f c0       	rjmp	.+30     	; 0x2a <__bad_interrupt>
   c:	0e c0       	rjmp	.+28     	; 0x2a <__bad_interrupt>
   e:	0d c0       	rjmp	.+26     	; 0x2a <__bad_interrupt>
  10:	0c c0       	rjmp	.+24     	; 0x2a <__bad_interrupt>
  12:	0b c0       	rjmp	.+22     	; 0x2a <__bad_interrupt>
  14:	0a c0       	rjmp	.+20     	; 0x2a <__bad_interrupt>
  16:	09 c0       	rjmp	.+18     	; 0x2a <__bad_interrupt>
  18:	94 c0       	rjmp	.+296    	; 0x142 <__vector_12>
  1a:	07 c0       	rjmp	.+14     	; 0x2a <__bad_interrupt>
  1c:	06 c0       	rjmp	.+12     	; 0x2a <__bad_interrupt>

0000001e <__ctors_end>:
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf ed       	ldi	r28, 0xDF	; 223
  24:	cd bf       	out	0x3d, r28	; 61
  26:	ae d0       	rcall	.+348    	; 0x184 <main>
  28:	be c0       	rjmp	.+380    	; 0x1a6 <_exit>

0000002a <__bad_interrupt>:
  2a:	ea cf       	rjmp	.-44     	; 0x0 <__vectors>

0000002c <ass_i2c_delay_half>:

void sleepUntilISR() {
	SETBIT( RX8900_INT_PORT ,RX8900_INT_BIT );	// Enable pull up
	while ( !GETBIT( RX8900_INT_PORT ,RX8900_INT_BIT  ) );
	sleep_cpu();	
	CLRBIT( RX8900_INT_PORT ,RX8900_INT_BIT );	// Disable pull up	
  2c:	91 e0       	ldi	r25, 0x01	; 1

0000002e <_Lidelay>:
  2e:	9a 95       	dec	r25
  30:	f1 f7       	brne	.-4      	; 0x2e <_Lidelay>
  32:	08 95       	ret
  34:	08 95       	ret

00000036 <ass_i2c_wait_scl_high>:
  36:	b3 9b       	sbis	0x16, 3	; 22
  38:	fe cf       	rjmp	.-4      	; 0x36 <ass_i2c_wait_scl_high>
  3a:	a8 94       	cln
  3c:	08 95       	ret
  3e:	08 95       	ret

00000040 <_Z8i2c_initv>:
  40:	b9 98       	cbi	0x17, 1	; 23
  42:	bb 98       	cbi	0x17, 3	; 23
  44:	c1 9a       	sbi	0x18, 1	; 24
  46:	c3 9a       	sbi	0x18, 3	; 24
  48:	88 27       	eor	r24, r24
  4a:	99 27       	eor	r25, r25
  4c:	b1 9b       	sbis	0x16, 1	; 22
  4e:	08 95       	ret
  50:	b3 9b       	sbis	0x16, 3	; 22
  52:	08 95       	ret
  54:	81 e0       	ldi	r24, 0x01	; 1
  56:	08 95       	ret
  58:	81 e0       	ldi	r24, 0x01	; 1
  5a:	08 95       	ret

0000005c <_Z9i2c_starth>:
  5c:	b3 9b       	sbis	0x16, 3	; 22
  5e:	eb df       	rcall	.-42     	; 0x36 <ass_i2c_wait_scl_high>
  60:	c1 98       	cbi	0x18, 1	; 24
  62:	b9 9a       	sbi	0x17, 1	; 23
  64:	e3 df       	rcall	.-58     	; 0x2c <ass_i2c_delay_half>
  66:	11 d0       	rcall	.+34     	; 0x8a <ass_i2c_write>
  68:	08 95       	ret
  6a:	81 e0       	ldi	r24, 0x01	; 1
  6c:	08 95       	ret

0000006e <ass_i2c_stop>:
  6e:	c3 98       	cbi	0x18, 3	; 24
  70:	bb 9a       	sbi	0x17, 3	; 23
  72:	c1 98       	cbi	0x18, 1	; 24
  74:	b9 9a       	sbi	0x17, 1	; 23
  76:	da df       	rcall	.-76     	; 0x2c <ass_i2c_delay_half>
  78:	bb 98       	cbi	0x17, 3	; 23
  7a:	c3 9a       	sbi	0x18, 3	; 24
  7c:	d7 df       	rcall	.-82     	; 0x2c <ass_i2c_delay_half>
  7e:	b3 9b       	sbis	0x16, 3	; 22
  80:	da df       	rcall	.-76     	; 0x36 <ass_i2c_wait_scl_high>
  82:	b9 98       	cbi	0x17, 1	; 23
  84:	c1 9a       	sbi	0x18, 1	; 24
  86:	d2 df       	rcall	.-92     	; 0x2c <ass_i2c_delay_half>
  88:	08 95       	ret

0000008a <ass_i2c_write>:
  8a:	08 94       	sec
  8c:	88 1f       	adc	r24, r24
  8e:	01 c0       	rjmp	.+2      	; 0x92 <_Li2c_write_first>

00000090 <_Li2c_write_bit>:
  90:	88 0f       	add	r24, r24

00000092 <_Li2c_write_first>:
  92:	d9 f0       	breq	.+54     	; 0xca <_Li2c_get_ack>
  94:	c3 98       	cbi	0x18, 3	; 24
  96:	bb 9a       	sbi	0x17, 3	; 23
  98:	00 00       	nop
  9a:	00 00       	nop
  9c:	00 00       	nop
  9e:	20 f4       	brcc	.+8      	; 0xa8 <_Li2c_write_low>
  a0:	00 00       	nop
  a2:	b9 98       	cbi	0x17, 1	; 23
  a4:	c1 9a       	sbi	0x18, 1	; 24
  a6:	03 c0       	rjmp	.+6      	; 0xae <_Li2c_write_high>

000000a8 <_Li2c_write_low>:
  a8:	c1 98       	cbi	0x18, 1	; 24
  aa:	b9 9a       	sbi	0x17, 1	; 23
  ac:	00 c0       	rjmp	.+0      	; 0xae <_Li2c_write_high>

000000ae <_Li2c_write_high>:
  ae:	be df       	rcall	.-132    	; 0x2c <ass_i2c_delay_half>
  b0:	bb 98       	cbi	0x17, 3	; 23
  b2:	c3 9a       	sbi	0x18, 3	; 24
  b4:	a8 94       	cln
  b6:	00 00       	nop
  b8:	00 00       	nop
  ba:	00 00       	nop
  bc:	b3 9b       	sbis	0x16, 3	; 22
  be:	bb df       	rcall	.-138    	; 0x36 <ass_i2c_wait_scl_high>
  c0:	12 f4       	brpl	.+4      	; 0xc6 <_Ldelay_scl_high>

000000c2 <_Li2c_write_return_false>:
  c2:	88 27       	eor	r24, r24
  c4:	15 c0       	rjmp	.+42     	; 0xf0 <_Li2c_write_return>

000000c6 <_Ldelay_scl_high>:
  c6:	b2 df       	rcall	.-156    	; 0x2c <ass_i2c_delay_half>
  c8:	e3 cf       	rjmp	.-58     	; 0x90 <_Li2c_write_bit>

000000ca <_Li2c_get_ack>:
  ca:	c3 98       	cbi	0x18, 3	; 24
  cc:	bb 9a       	sbi	0x17, 3	; 23
  ce:	00 00       	nop
  d0:	00 00       	nop
  d2:	b9 98       	cbi	0x17, 1	; 23
  d4:	c1 9a       	sbi	0x18, 1	; 24
  d6:	aa df       	rcall	.-172    	; 0x2c <ass_i2c_delay_half>
  d8:	99 27       	eor	r25, r25
  da:	88 27       	eor	r24, r24
  dc:	bb 98       	cbi	0x17, 3	; 23
  de:	c3 9a       	sbi	0x18, 3	; 24

000000e0 <_Li2c_ack_wait>:
  e0:	a8 94       	cln
  e2:	00 00       	nop
  e4:	b3 9b       	sbis	0x16, 3	; 22
  e6:	a7 df       	rcall	.-178    	; 0x36 <ass_i2c_wait_scl_high>
  e8:	62 f3       	brmi	.-40     	; 0xc2 <_Li2c_write_return_false>
  ea:	b1 9b       	sbis	0x16, 1	; 22
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	9e df       	rcall	.-196    	; 0x2c <ass_i2c_delay_half>

000000f0 <_Li2c_write_return>:
  f0:	00 00       	nop
  f2:	00 00       	nop
  f4:	c3 98       	cbi	0x18, 3	; 24
  f6:	bb 9a       	sbi	0x17, 3	; 23
  f8:	08 95       	ret
  fa:	81 e0       	ldi	r24, 0x01	; 1
  fc:	08 95       	ret

000000fe <_Z15movement_mid_onh>:
  fe:	81 11       	cpse	r24, r1
 100:	c4 9a       	sbi	0x18, 4	; 24
 102:	bc 9a       	sbi	0x17, 4	; 23
 104:	08 95       	ret

00000106 <_Z16movement_mid_offv>:
 106:	bc 98       	cbi	0x17, 4	; 23
 108:	c4 98       	cbi	0x18, 4	; 24
 10a:	08 95       	ret

0000010c <_Z14rx8900_reg_sethh>:
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	d8 2f       	mov	r29, r24
 112:	c6 2f       	mov	r28, r22
 114:	84 e6       	ldi	r24, 0x64	; 100
 116:	a2 df       	rcall	.-188    	; 0x5c <_Z9i2c_starth>
 118:	8d 2f       	mov	r24, r29
 11a:	b7 df       	rcall	.-146    	; 0x8a <ass_i2c_write>
 11c:	8c 2f       	mov	r24, r28
 11e:	b5 df       	rcall	.-150    	; 0x8a <ass_i2c_write>
 120:	a6 df       	rcall	.-180    	; 0x6e <ass_i2c_stop>
 122:	df 91       	pop	r29
 124:	cf 91       	pop	r28
 126:	08 95       	ret

00000128 <_Z21rx8900_fixed_timer_gov>:
 128:	62 e0       	ldi	r22, 0x02	; 2
 12a:	8b e0       	ldi	r24, 0x0B	; 11
 12c:	ef df       	rcall	.-34     	; 0x10c <_Z14rx8900_reg_sethh>
 12e:	60 e0       	ldi	r22, 0x00	; 0
 130:	8c e0       	ldi	r24, 0x0C	; 12
 132:	ec df       	rcall	.-40     	; 0x10c <_Z14rx8900_reg_sethh>
 134:	60 e5       	ldi	r22, 0x50	; 80
 136:	8f e0       	ldi	r24, 0x0F	; 15
 138:	e9 df       	rcall	.-46     	; 0x10c <_Z14rx8900_reg_sethh>
 13a:	6a e3       	ldi	r22, 0x3A	; 58
 13c:	8d e0       	ldi	r24, 0x0D	; 13
 13e:	e6 df       	rcall	.-52     	; 0x10c <_Z14rx8900_reg_sethh>
 140:	08 95       	ret

00000142 <__vector_12>:
 142:	18 95       	reti

00000144 <__vector_2>:
 144:	18 95       	reti

00000146 <__vector_1>:
 146:	18 95       	reti

00000148 <_Z9sleep16msv>:
 148:	88 e4       	ldi	r24, 0x48	; 72
 14a:	81 bd       	out	0x21, r24	; 33
 14c:	88 95       	sleep
 14e:	88 e1       	ldi	r24, 0x18	; 24
 150:	81 bd       	out	0x21, r24	; 33
 152:	11 bc       	out	0x21, r1	; 33
 154:	08 95       	ret

00000156 <_Z9sleep32msv>:
 156:	89 e4       	ldi	r24, 0x49	; 73
 158:	81 bd       	out	0x21, r24	; 33
 15a:	88 95       	sleep
 15c:	88 e1       	ldi	r24, 0x18	; 24
 15e:	81 bd       	out	0x21, r24	; 33
 160:	11 bc       	out	0x21, r1	; 33
 162:	08 95       	ret

00000164 <_Z5setupv>:

void setup() {
	
	
	// Enable pull-up on /INT pin. This is open-drain output on the RX8900 so we need to pull it up with the ATTINY.	
	SETBIT( RX8900_INT_PORT , RX8900_INT_BIT );		
 164:	c2 9a       	sbi	0x18, 2	; 24
		
	// Enable interrupt on pin change to wake us every time the fixed-cycle timer pulls /INT low.
	SETBIT( GIMSK  , PCIE );				//When the PCIE bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt is enabled.
 166:	8b b7       	in	r24, 0x3b	; 59
 168:	80 62       	ori	r24, 0x20	; 32
 16a:	8b bf       	out	0x3b, r24	; 59
	
	// Set up to deep sleep between interrupts
	sleep_enable();							// How to do once to enable sleep
 16c:	85 b7       	in	r24, 0x35	; 53
 16e:	80 62       	ori	r24, 0x20	; 32
 170:	85 bf       	out	0x35, r24	; 53
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);	// Lowest power, can wake on interrupts (pin change, WDT)
 172:	85 b7       	in	r24, 0x35	; 53
 174:	87 7e       	andi	r24, 0xE7	; 231
 176:	80 61       	ori	r24, 0x10	; 16
 178:	85 bf       	out	0x35, r24	; 53
	sei();									// Allow interrupts (so we can wake on them)
 17a:	78 94       	sei
			
	// Activate the movement pins
	//movement_activate();
	//SETBIT( DIDR0 , ADC2D );		// Turn off digital input buffer on the pin connected to the movement. This pin is often floating at Vcc midpoint, so this should keep the buffer from bouncing around. 

	SETBIT( PORTB , 0 );			// Pull up the currently unused pin so it does not float around. 
 17c:	c0 9a       	sbi	0x18, 0	; 24



void rx8900_init() {
	
	i2c_init();
 17e:	60 df       	rcall	.-320    	; 0x40 <_Z8i2c_initv>
// Does not reset the time counter

void rx8900_setup(void) {

	// rx8900_fout_32KHz();
	rx8900_fixed_timer_go();
 180:	d3 df       	rcall	.-90     	; 0x128 <_Z21rx8900_fixed_timer_gov>
 182:	08 95       	ret

00000184 <main>:
}

int main(void)
{

	setup();
 184:	ef df       	rcall	.-34     	; 0x164 <_Z5setupv>
		sleepUntilISR();
		*/
		

		//for( uint8_t phase : {0,1} ) {
		for(uint8_t phase=0; phase<2;phase++) {
 186:	c0 e0       	ldi	r28, 0x00	; 0

			// Disable /INT interrupt here to avoid spurious interrupt when /INT rises from waking us from WDT sleep.
			CLRBIT( PCMSK , RX8900_INT_INT );		//Disable interrupt on /INT pin change. This will prevent us from waking from the WDT delay sleep when this pin floats after the RTC stops pulling it low. 		
 188:	aa 98       	cbi	0x15, 2	; 21
			SETBIT( DIDR0 , ADC1D );				// Turn off digital input buffer on the pin connected to /INT so will not waste power when it floats when RTC stops pulling it low.
 18a:	a2 9a       	sbi	0x14, 2	; 20
			CLRBIT( RX8900_INT_PORT , RX8900_INT_BIT );	// Disable pull up. /INT Will be pulled low by RTC for ~7ms, so no need to waste power though the pull up.	
 18c:	c2 98       	cbi	0x18, 2	; 24
			
			movement_mid_on(phase);
 18e:	8c 2f       	mov	r24, r28
 190:	b6 df       	rcall	.-148    	; 0xfe <_Z15movement_mid_onh>
			sleep16ms();
 192:	da df       	rcall	.-76     	; 0x148 <_Z9sleep16msv>
			SETBIT( RX8900_INT_PORT , RX8900_INT_BIT );		// OK, /INT should be reset by the time we get here, so turn on the pull up again. This will give it time to pull the voltage back up by the time we are ready to sleep again. 
 194:	c2 9a       	sbi	0x18, 2	; 24
			sleep32ms();		
 196:	df df       	rcall	.-66     	; 0x156 <_Z9sleep32msv>
			movement_mid_off();
 198:	b6 df       	rcall	.-148    	; 0x106 <_Z16movement_mid_offv>
			
			CLRBIT( DIDR0 , ADC1D );				// Enable digital input buffer on the pin connected to /INT so we will see when RTC pulls it low
 19a:	a2 98       	cbi	0x14, 2	; 20
			SETBIT( PCMSK , RX8900_INT_INT );	// Enable interrupt on /INT pin change to wake us when RTC says we are ready for next tick. 
 19c:	aa 9a       	sbi	0x15, 2	; 21
		sleepUntilISR();
		*/
		

		//for( uint8_t phase : {0,1} ) {
		for(uint8_t phase=0; phase<2;phase++) {
 19e:	cf 5f       	subi	r28, 0xFF	; 255
 1a0:	c2 30       	cpi	r28, 0x02	; 2
 1a2:	91 f7       	brne	.-28     	; 0x188 <main+0x4>
 1a4:	f0 cf       	rjmp	.-32     	; 0x186 <main+0x2>

000001a6 <_exit>:
 1a6:	f8 94       	cli

000001a8 <__stop_program>:
 1a8:	ff cf       	rjmp	.-2      	; 0x1a8 <__stop_program>
